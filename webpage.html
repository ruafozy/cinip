<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
  "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
        <meta http-equiv="Content-type" content="text/html; charset=UTF-8">

    <title>Cinip makes bcmath easier to use</title>

          <base href="http://kingfisher.nfshost.com/sw/cinip/">
          <style type="text/css" media="all">
	
.container1, .container2 {
  margin: 0 auto 0 0;
}

.container1 {
  max-width: 60em;
}

.container2 {
  max-width: 70ex;
}

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
}

.wrapper {
  min-height: 100%;

  /* required for IE 6, it seems */
  height: auto !important;
  height: 100%;

  margin: 0 auto -3em;
}

.push {
  height: 3em;
  margin: 0;
}

body.numconns .push {
  clear: both;
}

.footer {
  height: 1em;
  padding: 1em 0;
  margin: 0;
}

.lastmod {
  text-align: center;
  margin: 0;
}

.lastmod .description {
  font-variant: small-caps;
  text-transform: lowercase;
  font-weight: bold;
}

.navbar {
  border-bottom: solid medium;
  padding: 1ex 0 0 1ex;
  margin-bottom: 1em;
}

.navbar a {
  float: left;
  padding: 1em;
  border: solid .3333em;
  margin-right: 1em;
  margin-bottom: 1em;
  text-transform: uppercase;
  text-decoration: none;
}

.navbar a:hover {
  padding: .5em;
  border: solid .8333em;
}

.content {
  margin: 0;
  padding: 0 1em;
}

.content > *:last-child {
  margin-bottom: 0;
}

.code {
  font-family: monospace;
  margin: 1em 0 1em 0;
  white-space: pre;
  white-space: pre-wrap;
}

.indent {
  margin-left: 6ex;
}

.term_box {
  /*
    float: right;
    width: 50%;
    margin: 1.5ex;
  */
  margin: 1em 0;
  padding: 0 1.2ex;
  border: dashed thin;
}

.term_box .term { display: none; }

body.cinip table.not-implemented th {
  padding-bottom: 1em;
  padding-left: 4em;
  text-align: left;
}

body.cinip table.not-implemented th:first-child {
  padding-left: 0;
}

body.cinip table.not-implemented td {
  vertical-align: top;
}

body.cinip table.not-implemented .code2 {
  margin: 0 0 3em 4em;
}

body.cinip table.not-implemented > tbody > tr.last-row > td > .code2 {
  margin-bottom: 1.6em;
}

div.code-variant {
  float: left;
  width: 50%;
  margin: 0;
  padding: 0;
  font-family: monospace;
}

div.code-variant-inner {
  margin: 0;
  padding: 1em 1ex;
  border: solid thin;
}

div.code-variant-inner-left { margin-right: .75em; }
div.code-variant-inner-right { margin-left: .75em; }

zzz div.code-variant { background-color: #f00; }
zzz div.code-variant-inner { background-color: #0f0; }

zzz body.cinip table.not-implemented {
  border-spacing: 6em 2em;
}

zzz body.cinip table.not-implemented {
  outline: 1px solid;
  width: auto;
  margin-left: auto;
  margin-right: auto;
}

zzz body.cinip table.not-implemented .code2 { background-color: #f0f; }
zzz body.cinip table.not-implemented th, zzz body.cinip table.not-implemented td { background-color: #f00; }

.code2 {
  margin: 1em 0 1em 4ex;
}

.code2 .code_line {
  margin: 0;
  font-family: monospace;
  white-space: pre;
  white-space: pre-wrap;
  /*
  outline: solid #0f0 1px;
  */
}

.code-with-link .code2 {
  margin-bottom: 0;
}

.code-with-link .code-link {
  text-align: center;
  margin-bottom: 2em;
}

.note {
  margin: 1em 0;
  padding: 1.2ex;
  border: dashed thin;
}

.note:before {
  content: "Note: ";
  font-weight: bold;
}

div.note2 {
  border: dashed thin;
  padding: 0 1em;
  margin: 1.5em 0;
  font-style: italic;
}

div.note2 span.intro {
  font-style: normal;
  font-weight: bold;
}

.note3 {
  font-size: smaller;
  font-style: italic;
  margin-left: 4em;
  margin-right: 4em;
}

zzz .note3:after {
  font-size: larger;
  white-space: pre;
  content: "\a\a\a\a\a\a";
  content: "\a\a";
}

dl.opt_keys > dt {
  font-weight: bold;
}

.nobr {
  white-space: nowrap;
}

.temporal_sequence > li {
  list-style-type: disc;
}

.commands {
  margin: 2ex 0;
}

.command {
  font-family: monospace;
  white-space: pre;
  padding-left: 5ex;
}

.command:after {
  content: "\a";
}

.centred-image {
  text-align: center;
}

/*
  .term_box .term {
    font-weight: bold;
    display: inline;
  }

  .term_box .term:after {
    content: ",";
  }

  li .term_box .term:first-child:after {
    content: none;
  }
*/

.phpcode {
  background-color: #fff;
  border: solid thin;
  padding: 1em;
}
.phpcode * {
  white-space: pre;
  white-space: pre-wrap;
}

.func-sig {
  font-family: monospace;
  font-style: normal;
  font-weight: bold;
}
.func-sig .func-param {
  font-family: serif;
  font-style: italic;
  font-weight: normal;
}
span.func-sig span.opt-part {
  font-family: serif;
  font-style: italic;
  font-weight: normal;
}
span.func-sig span.opt-param-default {
  font-family: monospace;
  font-style: normal;
  font-weight: normal;
}

#mersenne-twister {
  font-family: serif;
}

#mersenne-twister #mersenne-stats .indices {
  width: 5ex;
}

#mersenne-twister #mersenne-stats {
  border-collapse: separate;
  border-spacing: 1em;
  margin: 1em 0;
  border: dotted 1px;
}

.operators {
  margin-left: 6ex;
  margin-bottom: 1em;
}

.operators > .operator {
  font-weight: 900;
  font-family: monospace;
  font-size: larger;
  margin: 0 3ex;
}

zzz .extcode { border-right: 1px dotted; }

/*
#mersenne-twister #mersenne-stats .heading {
  border-bottom: solid thin;
}

#mersenne-stats td { border: solid thin }
*/

body.changewords .contains_text {
  margin: 1ex;
  padding: 1ex;
  border: thin solid;
  background-color: white;
  color: black;
}

body.changewords .highlight_words .word {
  background-color: red;
}

body.changewords .highlight_words .word_being_changed {
  background-color: yellow;
}

body.changewords .debug {
  white-space: pre;
}

dl.sw-list dt {
  font-size: 142%;
  font-weight: bold;
}

.footnote-ref {
  vertical-align: super;
}

.footnote-ref-back {
  text-decoration: none;
  font-size: smaller;
  vertical-align: top;
}

.footnote-ref-back:hover {
  text-decoration: underline;
}

.code-display {
  background-color: white;
  color: black;
  margin: 1em 0;
  border: solid thin black;

  outline: solid thin;
  outline: none;
}

.code-display code {
  margin: 0;
  display: block;
  padding: 1ex;
}

.code-display .code2 {
  margin: 0;
  border: 0;
  padding: 0;
}

.code-display .output:before {
  content: 'Output';
  display: block;
  font-weight: bold;
  font-size: 1.6em;
  font-size: large;
  margin: 1em 0 1em 0;
  margin: 1ex 0 1ex 0;
  margin: 1ex 0;
}

.code-display .output {
  margin-top: 1em 0 0 0;
  padding: 1ex;
}

.code-display .output .code_line:before {
  content: "\0025B6  ";
  display: block;
  display: inline;
  position: absolute;
  position: static;
  left: auto;
  color: black;
  color: lime;
  color: green;
  color: red;
  background-color: white;
}

      </style>
    
    
	<style type='text/css'>
	  body:before {
	    content: '[rewritten to .tpl]';
	    font-style: italic;
	    display: block;
	    position: absolute;
	    right: 1em;
	  }
	</style>
      
  </head>
    <body class="cinip">
    <div class="wrapper">
      <div class="container1">
	<div class="container2">
	  <div class="navbar">
	    	    <a href="/">Home</a>
	    <a href="/contact.html">Contact</a>
	    <div style="clear: both"></div>
	  </div>

	  <div class="content">
	    <h1>Cinip: big numbers, arbitrary precision, <em>conveniently</em></h1>

<h2>Introduction</h2>

<p>
  PHP has an extension called
  <a href="http://php.net/manual/en/book.bc.php">BCMath</a>, which
  allows the use of numbers of arbitrary size, with
  a configurable number of digits after the decimal point.
  However, it can force the programmer to use expressions
  which are painful to write and difficult to read.

<p>
  Imagine that you need to compute the following expression:

  <div class='code2'>
<div class='code_line'>($a * $b + $c) * ($d * $e + $f) / ($g * $h + $i) * ($j * $k + $l)</div>
</div>


  You know that the numbers involved are large and that they may
  overflow PHP's numeric datatypes, so you have to use BCMath.
  But to express the above, you have
  to write this:

  <div class='code2'>
<div class='code_line'>bcmul(</div>
<div class='code_line'>  bcdiv(</div>
<div class='code_line'>    bcmul(</div>
<div class='code_line'>      bcadd(bcmul($a, $b), $c),</div>
<div class='code_line'>      bcadd(bcmul($d, $e), $f),</div>
<div class='code_line'>    ),</div>
<div class='code_line'>    bcadd(bcmul($g, $h), $i),</div>
<div class='code_line'>  ),</div>
<div class='code_line'>  bcadd(bcmul($j, $k), $l),</div>
<div class='code_line'>)</div>
</div>


<p>
  Wouldn't it be nice if you could use a more readable, more
  PHP-like notation?
  Well, now you can, and this page describes how.

<p>
  The necessary software is called Cinip, and
  its usage is very simple.
  (The name is an acronym for
  &ldquo;Calculate Immense Numbers in PHP&rdquo;,
  and I pronounce it as “SINN-ipp”.)
  Currently at version 1.0.0, it is
  in the public domain and available
  for download in 
  <a href="/archives/cinip-1.0.0.tgz">tgz</a> and
  <a href="/archives/cinip-1.0.0.zip">zip</a> formats.
  It requires PHP 5.3.0 or later.

<p>
  The remainder of this document explains how to use
  the software;
  in what follows,
  a knowledge of BCMath is helpful, but not required.

<h2>A simple example</h2>

<p>
  To solve the problem just
  described, we might use something like the following code.
  It performs the calculation given above and assigns its result
  to <tt>$x</tt>.

  <div class='code2'>
<div class='code_line'>$f = new cinip\parser::get_func(500);</div>
<div class='code_line'>/*</div>
<div class='code_line'>  We want calculations to</div>
<div class='code_line'>  use 500 decimal places;</div>
<div class='code_line'>  Cinip's default is 60.</div>
<div class='code_line'>*/</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$expression = '</div>
<div class='code_line'>  ($a * $b + $c) * ($d * $e + $f) / ($g * $h + $i) * ($j * $k + $l)</div>
<div class='code_line'>';</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$x = eval($f($expression));</div>
</div>


<h2>A longer example</h2>

<p>
  The following is a complete program
  (which doesn't show Cinip to best advantage, since
  the arithmetic expressions are not very complicated).
  Note that the scale (the first argument to the static method
  <tt>get_func</tt>) is always zero, since we are dealing only with
  integers.

<div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>require_once &quot;cinip.php&quot;;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  All of Cinip is defined in</div>
<div class='code_line'>  the file cinip.php</div>
<div class='code_line'>*/</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  Everything defined in</div>
<div class='code_line'>  cinip.php is in the above</div>
<div class='code_line'>  namespace</div>
<div class='code_line'>*/</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>test_gcd();</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  test the function</div>
<div class='code_line'>  `gcd', defined below</div>
<div class='code_line'>*/</div>
<div class='code_line'>function test_gcd() {</div>
<div class='code_line'>  $fac100 = factorial(100);</div>
<div class='code_line'>  $fac200 = factorial(200);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>  $f = cinip\parser::get_func(0);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>  if(eval($f('gcd($fac100, $fac200) != $fac100'))) {</div>
<div class='code_line'>    print &quot;Something's very wrong...\n&quot;;</div>
<div class='code_line'>  }</div>
<div class='code_line'>}</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>function factorial($n) {</div>
<div class='code_line'>  $f = cinip\parser::get_func(0);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>  $fac = 1;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>  for($i = 2; $i &lt;= $n; $i++)</div>
<div class='code_line'>    $fac = eval($f('$fac * $i'));</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>  return $fac;</div>
<div class='code_line'>}</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  calculate the greatest</div>
<div class='code_line'>  common divisor of $a</div>
<div class='code_line'>  and $b, using Euclid's</div>
<div class='code_line'>  algorithm</div>
<div class='code_line'>*/</div>
<div class='code_line'>function gcd($a, $b) {</div>
<div class='code_line'>  $f = cinip\parser::get_func(0);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>  while(eval($f('$b != 0'))) {</div>
<div class='code_line'>    list($a, $b) = array($b, eval($f('$a % $b')));</div>
<div class='code_line'>  }</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>  return $a;</div>
<div class='code_line'>}</div>
</div>


<h2>API</h2>

<p>
  All of Cinip is contained
  in a single file (called <tt>cinip.php</tt>, but
  you can rename it if you like),
  which should be loaded with <tt>require_once</tt> or <tt>include_once</tt>.
  Everything in this file is defined in the namespace
  <tt>\kingfisher\cinip</tt>.

<p>
  Among the things defined are two classes
  called <tt>parser</tt> and <tt>CinipException</tt>,
  and an interface called <tt>Exception</tt>.
  These three things constitute the API, and everything
  else should be considered private.

<p>
  In a moment we will look at
  the methods of the class <tt>parser</tt>,
  but first we need to consider
  the static method <tt>get_func</tt> and its relationship to two
  other methods of <tt>parser</tt>.

<p>
  <tt>get_func</tt> allows one to eliminate some clutter.
  Consider the following two pieces of code, which
  are essentially equivalent.
</p>



<div style='clear: both; margin: 0'></div>

<div class=code-variant>
  <div class="code-variant-inner code-variant-inner-left">
    use kingfisher\cinip;
    <br>
    <br>
    <span style='margin-left: 6ex'>&#x22ee;</span>    <br>
    <br>
    $parser = new cinip\parser(<span style='font-style: italic; font-family: serif'>x<sub>1</sub>, x<sub>2</sub>, &hellip;, x<sub>m</sub></span>);
    <br>
    <br>
    <span style='margin-left: 6ex'>&#x22ee;</span>    <br>
    <br>
    $z = eval($parser->to_bc(<span style='font-style: italic; font-family: serif'>y<sub>1</sub>, y<sub>2</sub>, &hellip;, y<sub>n</sub></span>));
    <br>
  </div>
</div>

<div class=code-variant>
  <div class="code-variant-inner code-variant-inner-right">
    use kingfisher\cinip;
    <br>
    <br>
    <span style='margin-left: 6ex'>&#x22ee;</span>    <br>
    <br>
    $f = cinip\parser::get_func(<span style='font-style: italic; font-family: serif'>x<sub>1</sub>, x<sub>2</sub>, &hellip;, x<sub>m</sub></span>);
    <br>
    <br>
    <span style='margin-left: 6ex'>&#x22ee;</span>    <br>
    <br>
    $z = eval($f(<span style='font-style: italic; font-family: serif'>y<sub>1</sub>, y<sub>2</sub>, &hellip;, y<sub>n</sub></span>));
    <br>
  </div>
</div>

<div style='clear: both; margin: 0'></div>


<p>
  Clearly,
  &ldquo;<tt>eval($f(<span style='font-family: serif'>&hellip;</span>))</tt>&rdquo;
  is more convenient to read
  and write
  than
  &ldquo;<tt>eval($parser->to_bc(<span style='font-family: serif'>&hellip;</span>))</tt>&rdquo;.

<h3>Methods of the class <tt>parser</tt></h3>

<dl>
  <dt><span class='func-sig'>to_bc(<span class=func-param>$arithmetic_expression</span>)</span>

  <dd>
    <p>
      Parses <i>$arithmetic_expression</i>, transforms it
      into a new expression which uses BCMath
      functions, and returns this new expression.
      (The syntax rules for <i>$arithmetic_expression</i>
      are given below.)

    <p>
      Here is a small program which illustrates the use
      of <tt>to_bc</tt>.

      <div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>require_once &quot;cinip.php&quot;;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$parser = new cinip\parser;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$x = 1;</div>
<div class='code_line'>$y = 2;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$expressions = array(</div>
<div class='code_line'>  '1 + 2',</div>
<div class='code_line'>  '$x + $y',</div>
<div class='code_line'>  'pow(PHP_INT_MAX, 20) / log(33, 10)',</div>
<div class='code_line'>  '1e200 / 3e400',</div>
<div class='code_line'>);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>foreach ($expressions as $e) {</div>
<div class='code_line'>  $new_expr = $parser-&gt;to_bc($e);</div>
<div class='code_line'>  $result = eval($new_expr);</div>
<div class='code_line'>  print</div>
<div class='code_line'>    &quot;Original expression: $e\n&quot; .</div>
<div class='code_line'>    &quot;Transformed expression: &quot; .</div>
<div class='code_line'>      &quot;$new_expr\n&quot; .</div>
<div class='code_line'>    &quot;Result: $result\n\n&quot;;</div>
<div class='code_line'>}</div>
</div>


  <dt><span class='func-sig'>__construct(<span class=opt-part>&nbsp;[&nbsp;<span class=func-param>$scale</span> = <span class=opt-param-default>60</span> &nbsp;[&nbsp;, <span class=func-param>$perf_mode</span> = <span class=opt-param-default>parser::memoize</span>&nbsp;]&nbsp;&nbsp;]&nbsp;</span>)</span>

  <dd>
    <p>
      <i>$scale</i> (which is analogous to PHP's <tt>bcmath.scale</tt> setting)
      is passed by Cinip to all BCMath functions
      which take a scale parameter (that is, all
      functions except <tt>bcmod</tt>).
      The scale can't be changed after an object
      has been created; if you need more precision,
      just create another <tt>parser</tt> object.

    <p>
      If you will be working only with integers,
      then setting <i>$scale</i> to 0 will make your calculations
      faster.

    <p>
      A feature of BCMath is worth highlighting: it appears
      that the scale is used, not just for the final
      result of a calculation, but also for the intermediate
      results.  This can result in truncation, as shown by
      the following program.
    </p>

    <div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>$result = bcmul('.13', '.13', 3);</div>
<div class='code_line'>/*</div>
<div class='code_line'>  the correct answer,</div>
<div class='code_line'>  mathematically speaking,</div>
<div class='code_line'>  is 0.0169</div>
<div class='code_line'>*/</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$result = ltrim($result, '0');</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>if($result === '.016') {</div>
<div class='code_line'>  print &quot;Truncation occurred.\n&quot;;</div>
<div class='code_line'>} elseif($result === '.017') {</div>
<div class='code_line'>  print &quot;Rounding occurred.\n&quot;;</div>
<div class='code_line'>} else {</div>
<div class='code_line'>  print &quot;Something completely &quot; .</div>
<div class='code_line'>    &quot;unexpected occurred.\n&quot;;</div>
<div class='code_line'>}</div>
</div>


    <p>
      Note that <tt>bcmath.scale</tt> has no effect on Cinip.

    <p>
      <i>$perf_mode</i> can be one of two class
      constants, <tt>parser::memoize</tt> or <tt>parser::no_enhancement</tt>.
      The former tells the object to
      <a href="http://foldoc.org/memoize">memoize</a> the method
      <tt>to_bc</tt> (which is described below), the latter tells it not to.

    <p>
      Normally you should use <tt>parser::memoize</tt>, but
      if each of your expressions is evaluated only once,
      or you have a large number of distinct expressions and are
      worried about high memory usage, then it may be better to use
      <tt>parser::no_enhancement</tt>.


  <dt><span class='func-sig'>get_func(<span class=opt-part>&nbsp;[&nbsp;<span class=func-param>$scale</span> = <span class=opt-param-default>60</span> &nbsp;[&nbsp;, <span class=func-param>$perf_mode</span> = <span class=opt-param-default>parser::memoize</span>&nbsp;]&nbsp;&nbsp;]&nbsp;</span>)</span>

  <dd>
    <p>
      A static method.  Has been fully described above.

  <dt><span class='func-sig'>get_scale()</span>

  <dd>
    <p>
      Returns the scale being used.

  <dt><span class='func-sig'>get_perf_mode()</span>

  <dd>
    <p>
      Returns the performance mode being used (one of
      <tt>parser::memoize</tt> or <tt>parser::no_enhancement</tt>).
</dl>

<h3>Syntax rules for expressions</h3>

<p>
  The syntax of expressions is a subset of that of PHP
  expressions.
  The following code gives a good overview of what
  may appear in a Cinip expression;
  it generates a
  valid expression and stores it in the variable <tt>$expression</tt>.

  <div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>require_once &quot;cinip.php&quot;;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$expression = implode(&quot;+&quot;,</div>
<div class='code_line'>  array(</div>
<div class='code_line'>    # integers can be used...</div>
<div class='code_line'>    '123',</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>    # as can floating-point</div>
<div class='code_line'>    # numbers...</div>
<div class='code_line'>    '1.2',</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>    # numbers in scientific</div>
<div class='code_line'>    # notation...</div>
<div class='code_line'>    '1e2',</div>
<div class='code_line'>    '3.4e5',</div>
<div class='code_line'>    '-6.7e-8',</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>    /*</div>
<div class='code_line'>      string literals using</div>
<div class='code_line'>      double quotes (with</div>
<div class='code_line'>      some complications,</div>
<div class='code_line'>      described below)...</div>
<div class='code_line'>    */</div>
<div class='code_line'>    '&quot;123&quot;',</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>    /*</div>
<div class='code_line'>      string literals using</div>
<div class='code_line'>      single quotes...</div>
<div class='code_line'>    */</div>
<div class='code_line'>    &quot;'123'&quot;,</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>    # variables...</div>
<div class='code_line'>    '$x',</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>    # any constant...</div>
<div class='code_line'>    'PHP_INT_MAX',</div>
<div class='code_line'>    'M_PI',</div>
<div class='code_line'>    'M_E',</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>    # any function.</div>
<div class='code_line'>    'log(100)',</div>
<div class='code_line'>    'rand(1, 10)',</div>
<div class='code_line'>  )</div>
<div class='code_line'>);</div>
</div>


<p>
  The following arithmetic operators are permitted:

  <div class=operators>
    <span class=operator>+</span>
    <span class=operator>-</span>
    <span class=operator>*</span>
    <span class=operator>/</span>
    <span class=operator>%</span>
  </div>

<p>
  They are implemented using the corresponding BCMath functions.
  (Note that, just as in PHP,
  &ldquo;<tt>+</tt>&rdquo;
  and
  &ldquo;<tt>-</tt>&rdquo;
  can be used as binary or as unary operators.)

<p>
  The following comparison operators are permitted:

  <div class=operators>
    <span class=operator>&lt;</span>
    <span class=operator>&lt;=</span>
    <span class=operator>==</span>
    <span class=operator>&gt;=</span>
    <span class=operator>&gt;</span>
    <span class=operator>!=</span>
  </div>

  They are implemented using <tt>bccomp</tt>, which
  means that they are accurate only as far as the scale
  permits; see the following code.

  <div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>require_once &quot;cinip.php&quot;;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$f = cinip\parser::get_func(3);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>if(eval($f('.111 == .1111'))) {</div>
<div class='code_line'>  print &quot;They are the same.\n&quot;;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>  /*</div>
<div class='code_line'>    This branch will be</div>
<div class='code_line'>    entered, because the</div>
<div class='code_line'>    scale is too low.</div>
<div class='code_line'>  */</div>
<div class='code_line'>}</div>
</div>

<p>
  Nesting to arbitrary depth is, of course, permitted:

  <div class='code2'>
<div class='code_line'>a(1, b($x, c(PHP_INT_MAX, d(log(42)))))</div>
</div>


<p>
  Any function can be used, but
  two functions are treated specially,
  namely <tt>sqrt</tt> and <tt>pow</tt>.

<p>
  <tt>sqrt</tt> will be changed to <tt>bcsqrt</tt>.
  For <tt>pow</tt>,
  a run-time check will be made on
  the second argument; if it's an integer (that
  is, an integer in the mathematical sense;
  it need not have type <tt>integer</tt>),
  then <tt>bcpow</tt> will be used; otherwise <tt>pow</tt> will be used.
  
<p>
  It's your responsibility to ensure that a function's arguments 
  are appropriate.  For example, the
  expression <tt>log(pow(2, 2000))</tt>
  won't work, because 2<sup>2000</sup>
  is too large to be
  represented as a double-precision floating-point number.

<h3>Things that don't work</h3>

<table class=not-implemented>
  <colgroup>
    <col width="20%">
    <col>
  </colgroup>
  <tr>
    <th>Description
    <th>Example of erroneous code

  <tr>
    <td>
      Using the <tt>-></tt> operator to reference properties or
      methods of an object.
    <td>
      <div class='code2'>
<div class='code_line'>$f = cinip\parser::get_func();</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  Each of these 2</div>
<div class='code_line'>  lines contains an</div>
<div class='code_line'>  invalid expression</div>
<div class='code_line'>*/</div>
<div class='code_line'>$x = eval($f('$o-&gt;a'));</div>
<div class='code_line'>$x = eval($f('$o-&gt;f()'));</div>
</div>


  <tr>
    <td>
      Referencing array elements.
    <td>
      <div class='code2'>
<div class='code_line'>$a = range(1, 9);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$f = cinip\parser::get_func();</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$x = eval($f('$a[0]'));</div>
</div>


  <tr>
    <td>
      Class constants
      (but you can use PHP's <tt>constant</tt>
      function).
    <td>
      <div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>require_once &quot;cinip.php&quot;;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>class C {</div>
<div class='code_line'>  const N = 100;</div>
<div class='code_line'>}</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$f = cinip\parser::get_func();</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$x = eval($f('C::N'));</div>
</div>


  <tr>
    <td>
      Certain kinds of
      interpolation into double-quoted strings.
    <td>
      <div class='code2'>
<div class='code_line'>$f = cinip\parser::get_func();</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$a = array();</div>
<div class='code_line'>$a[&quot;b&quot;][&quot;c&quot;] = 42;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$x = eval($f('100 + &quot;{$a[&quot;b&quot;][&quot;c&quot;]}&quot;'));</div>
</div>

  <tr class=last-row>
    <td>
      A name qualified with a namespace.
    <td>
      <div class='code2'>
<div class='code_line'>$f = cinip\parser::get_func();</div>
<div class='code_line'># both the following</div>
<div class='code_line'># Cinip expressions</div>
<div class='code_line'># are syntactically</div>
<div class='code_line'># invalid</div>
<div class='code_line'>$y = eval($f('100 + xyz\\g()'));</div>
<div class='code_line'>$y = eval($f('100 + namespace\\g()'));</div>
</div>

</table>

Adding these things should not be terribly difficult,
but would probably be quite tedious,
there being no good parser generator for PHP that
I know of.

<h4>More on interpolation</h4>

<p>
  Interpolation into double-quoted strings
  requires some explication.
  Cinip's idea of a double-quoted string is much
  simpler than PHP's, and can be explained
  using the following code.

  <div class='code2'>
<div class='code_line'>if(preg_match('@&quot;([^\\\\&quot;]|\\\\.)*&quot;@', $s)) {</div>
<div class='code_line'>  print &quot;The variable \$s contains a &quot; .</div>
<div class='code_line'>    &quot;double-quoted string literal.\n&quot;;</div>
<div class='code_line'>}</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  A note on the above regex:</div>
<div class='code_line'>  a backslash is special in PHP</div>
<div class='code_line'>  single-quoted strings, and</div>
<div class='code_line'>  special in regular expressions,</div>
<div class='code_line'>  so we need a sequence of 4</div>
<div class='code_line'>  backslashes to get a literal</div>
<div class='code_line'>  backslash in the regular</div>
<div class='code_line'>  expression.</div>
<div class='code_line'>*/</div>
</div>


<p>
  Because of this difference,
  Cinip and PHP sometimes differ on where a
  double-quoted string ends.  The result is that string
  interpolation will work if you use
  the simple syntax,
  but will not work for some uses of the complex syntax
  (these terms are from the
  <a href="http://www.php.net/manual/en/language.types.string.php#language.types.string.parsing">PHP documentation</a>).

<p>
  The following program (expanded from a code snippet above)
  illustrates.
  
  <div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>require_once &quot;cinip.php&quot;;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$f = cinip\parser::get_func();</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$a = array();</div>
<div class='code_line'>$a[&quot;b&quot;][&quot;c&quot;] = 42;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  this works because</div>
<div class='code_line'>  interpolation occurs</div>
<div class='code_line'>  before Cinip sees the</div>
<div class='code_line'>  expression</div>
<div class='code_line'>*/</div>
<div class='code_line'>$x = eval($f(&quot;100 + {$a[&quot;b&quot;][&quot;c&quot;]}&quot;));</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  this works because we used</div>
<div class='code_line'>  single-quotes inside the</div>
<div class='code_line'>  double-quoted string</div>
<div class='code_line'>*/</div>
<div class='code_line'>$x = eval($f('100 + &quot;{$a[\'b\'][\'c\']}&quot;'));</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  as far as Cinip is</div>
<div class='code_line'>  concerned, the first</div>
<div class='code_line'>  double-quoted string here</div>
<div class='code_line'>  is 4 characters long.</div>
<div class='code_line'>  as a result, interpolation</div>
<div class='code_line'>  will not occur.  in fact,</div>
<div class='code_line'>  this Cinip expression is</div>
<div class='code_line'>  syntactically invalid.</div>
<div class='code_line'>*/</div>
<div class='code_line'>$x = eval($f('100 + &quot;{$a[&quot;b&quot;][&quot;c&quot;]}&quot;'));</div>
</div>


<p>
  Interpolation is always done by PHP, not
  Cinip, with the time of interpolation being determined by
  the quoting used.
  The following program illustrates.

  <div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>require_once &quot;cinip.php&quot;;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$parser = new cinip\parser(0);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$x = str_repeat('2', 60);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  here, interpolation occurs</div>
<div class='code_line'>  before to_bc even begins</div>
<div class='code_line'>  to execute.</div>
<div class='code_line'>*/</div>
<div class='code_line'>$new_code = $parser-&gt;to_bc(&quot;111 + $x&quot;);</div>
<div class='code_line'>var_dump(eval($new_code));</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>/*</div>
<div class='code_line'>  here, interpolation occurs</div>
<div class='code_line'>  while eval is running</div>
<div class='code_line'>*/</div>
<div class='code_line'>$new_code = $parser-&gt;to_bc('111 + &quot;$x&quot;');</div>
<div class='code_line'>var_dump(eval($new_code));</div>
</div>


<h3>A small convenience</h3>

Numeric literals can have an arbitrary number
of digits before
or after the decimal point; unlike in PHP, there will be no
loss of precision (unless, of course, you've specified
a scale which is too low for the number of decimal digits).
See the following code for an example.

<div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>require_once &quot;cinip.php&quot;;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$f = cinip\parser::get_func();</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$x = str_repeat('2', 100000);</div>
<div class='code_line'>$y = str_repeat('1', 100000);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>if(eval($f(&quot;$x / 2 != $y&quot;))) {</div>
<div class='code_line'>  print &quot;Something's very wrong...\n&quot;;</div>
<div class='code_line'>}</div>
</div>


<h3>A warning</h3>

Be careful of interpolating
variables into double-quoted strings,
because precision may be lost.
See the following code.

<div class='code2'>
<div class='code_line'>require_once 'cinip.php';</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$precision = 14;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>ini_set('precision', $precision);</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$s = str_repeat('1', $precision);</div>
<div class='code_line'>$x = floatval($s . '0');</div>
<div class='code_line'>$y = floatval($s . '1');</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$f = cinip\parser::get_func();</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'># double quotes here</div>
<div class='code_line'>#</div>
<div class='code_line'>if(eval($f(&quot;$x != $y&quot;))) {</div>
<div class='code_line'>  print &quot;That's funny -- we should &quot; .</div>
<div class='code_line'>    &quot;have lost precision.\n&quot;;</div>
<div class='code_line'>}</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'># single quotes here</div>
<div class='code_line'>#</div>
<div class='code_line'>if(eval($f('$x == $y'))) {</div>
<div class='code_line'>  print &quot;That's funny -- \$x and \$y &quot; .</div>
<div class='code_line'>    &quot;should be different.\n&quot;;</div>
<div class='code_line'>}</div>
</div>


<h3>Exceptions</h3>

Cinip defines an interface called <tt>Exception</tt>.
It is guaranteed to be implemented by all exception classes
defined by Cinip, so to catch any exception
that the software may throw, you can
use code like the following.

<div class='code2'>
<div class='code_line'>&lt;?php</div>
<div class='code_line'>require_once &quot;cinip.php&quot;;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>use kingfisher\cinip;</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$f = cinip\parser::get_func();</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>$invalid_expression = '1 +';</div>
<div class='code_line'>&nbsp;</div>
<div class='code_line'>try {</div>
<div class='code_line'>  eval($f($invalid_expression));</div>
<div class='code_line'>} catch(cinip\Exception $e) {</div>
<div class='code_line'>  /*</div>
<div class='code_line'>    Any exception thrown by</div>
<div class='code_line'>    Cinip will be handled</div>
<div class='code_line'>    here.</div>
<div class='code_line'>  */</div>
<div class='code_line'>}</div>
</div>


Currently, Cinip defines only one exception class,
called <tt>CinipException</tt>.  
It is thrown, for example, when an expression cannot be parsed.
	  </div>
	</div>
      </div>

      <div class="push"></div>
    </div>

    <div class="footer">
      <div class="container1">
	<div class="container2">
	  <div class=lastmod>
	    <span class=description>Page last modified:</span>
	    2013-09-14	  </div>
	</div>
      </div>
    </div>
  </body>
</html>
